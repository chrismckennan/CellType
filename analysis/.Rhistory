alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
df.t.residual <- 3.9
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.vec <- c(0.1, 1, 2, 5, 10, 20, 50, 100, 1000, 1e4)
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
Gamma.und <- matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(mult.vec[i]/n.und) * sqrt(0.15)
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
df.t.residual <- 3.0
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.vec <- c(0.1, 1, 2, 5, 10, 20, 50, 100, 1000, 1e4)
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
df.t.residual <- 2.9
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.vec <- c(0.1, 1, 2, 5, 10, 20, 50, 100, 1000, 1e4)
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
Gamma.und <- matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(mult.vec[i]/n.und) * sqrt(0.15)
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
df.t.residual <- 3.0
p.und <- floor(327273 / 1)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.vec <- c(0.1, 1, 2, 5, 10, 20, 50, 100, 1000, 1e4)
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
Gamma.und <- matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(mult.vec[i]/n.und) * sqrt(0.15)
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
t(out.est$alpha.true) %*% out.est$alpha.true
t(out.est$alpha.hat) %*% out.est$alpha.hat
0.0385842/0.1374654
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
df.t.residual <- 3.0
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 1000
n.repeat <- 50
mult.vec <- c(0.1, 1, 2, 5, 10, 20, 50, 100, 1000, 1e4)
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
Gamma.und <- matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(mult.vec[i]/n.und) * sqrt(0.15)
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(0, nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
i
lm.vec[i]
norm.true.mat[j,]
norm.true.mat[,i]
j
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0), nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
t(out.est$alpha.true) %*% out.est$alpha.true
t(out.est$alpha.hat) %*% out.est$alpha.hat
0.003735862/0.1773036
alpha.und
t(Gamma.und / Sigma.und) %*% Gamma.und / p
t(Gamma.und / Sigma.und) %*% Gamma.und / p.und * n.und
i
out.est$alpha.hat
E <- E.ij
Gamma <- Gamma.und
Sigma<-Sigma.und
X <- X.und
dim(X)
alpha <- alpha.und
alpa
alpha
r <- ncol(Gamma)
p <- nrow(Gamma)
d <- ncol(X)
n <- nrow(X)
Q <- qr.Q(qr(X), complete=T)
R <- qr.R(qr(X))
Q1 <- Q[,1:d]
Q2 <- Q[,(d+1):n]
W <- matrix(rnorm(r*n), nrow=r, ncol=n)
W1 <- W %*% Q1     #r x d
E1 <- E %*% Q1
dim(E1)
E1[1,]
source("chunk-options.R")
source("../R/OptimizeLogLike.R")
source("../R/OptimizeLogLike_Ksigma.R")
source("../R/SimSparseData.R")
source("../R/EstimateBeta.R")
source("../R/CrudeEstDim.R")
source("../R/AnalyzeSimResults.R")
source("../R/PartialEM.R")
source("../R/UnderestimateOmega.R")
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
t(out.est$alpha.true) %*% out.est$alpha.true
t(out.est$alpha.hat) %*% out.est$alpha.hat
0.05714503/0.2573257
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
E.ij <- matrix(rt(n.und*p.und, df=df.t.residual), nrow=p.und, ncol=n.und) * sqrt((df.t.residual-2)/df.t.residual) * sqrt(0.15)
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.05), nrow=r.und, ncol=1)
out.est <- CompareEstimate2(X.und, alpha.und, E.ij, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
}
lm.
j
summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
ablint(a=0,b=0.25,col="red")
abline(a=0,b=0.25,col="red")
abline(a=0,b=0.26,col="red")
abline(a=0,b=0.30,col="blue")
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
abline(a=0,b=0.30,col="blue")
abline(a=0,b=0.27,col="blue")
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
x.i <- norm.true.mat[,i]
y.i <- norm.est.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.vec[i])
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
abline(a=0,b=0.25, col="blue")
abline(a=0,b=0.30, col="purple")
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.vec <- c(0.1, 1, 2, 5, 10, 20, 50, 100, 1000, 1e4)
mult.vec.i <- c(1, 3, 1000)
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=length(mult.vec))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
alpha.und
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
out.est$alpha.true
predicted.shrink.i <- sum(out.est$alpha.hat^2 * (mult.vec.i/(mult.vec.i))^2)
predicted.shrink.i
t(out.est$alpha.hat) %*% out.est$alpha.hat
predicted.shrink.i <- sum(out.est$alpha.true^2 * (mult.vec.i/(mult.vec.i))^2)
predicted.shrink.i
predicted.shrink.i <- sum(out.est$alpha.true^2 * (mult.vec.i/(mult.vec.i+1))^2)
predicted.shrink.i
t(out.est$alpha.hat - out.est$resid) %*% (out.est$alpha.hat - out.est$resid)
t(out.est$alpha.true) %*% out.est$alpha.true
out.est$alpha.true^2
t(Gamma.und / Sigma.und) %*% Gamma.und / p.und * n.und
mult.vec.i <- c(1000, 3, 1)
sum(out.est$alpha.true^2 * (mult.vec.i/(mult.vec.i+1))^2)
sum(out.est$alpha.true^2 * (sort(mult.vec.i)/(sort(mult.vec.i)+1))^2)
(mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
t(out.est$alpha.hat - out.est$resid) %*% (out.est$alpha.hat - out.est$resid)
predicted.shrink.i <- sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
predicted.shrink.i / 0.01777717
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
alpha.und <- c(0.4,0.4,0.4)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
t(out.est$alpha.hat) %*% out.est$alpha.hat
sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
t(out.est$alpha.hat - out.est$resid) %*% (out.est$alpha.hat - out.est$resid)
t(out.est$alpha.true) %*% out.est$alpha.true
0.3546221/0.3171128
mult.vec.i[order(-mult.vec.i)]
n.und <- 500
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
predicted.shrink.i <- sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
t(out.est$alpha.hat) %*% out.est$alpha.hat
predicted.shrink.i
t(out.est$alpha.true) %*% out.est$alpha.true
alpha.und
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
predicted.shrink.i <- sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
predicted.shrink.i
t(out.est$alpha.hat) %*% out.est$alpha.hat
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.mat <- cbind( c(1,1,1), c(1,2,2), c(1,2,5), c(1,2,1000) )
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=nrow(mult.mat))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=nrow(mult.mat))
norm.predict.mat <- matrix(NA, nrow=n.repeat, ncol=nrow(mult.mat))
lm.vec <- rep(NA, length(mult.vec))
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.mat <- cbind( c(1,1,1), c(1,2,2), c(1,2,5), c(1,2,1000) )
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=nrow(mult.mat))
norm.predict.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.mat <- cbind( c(1,1,1), c(1,2,2), c(1,2,5), c(1,2,1000) )
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=nrow(mult.mat))
norm.predict.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
i <- 1
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.mat <- cbind( c(0.1, 0.1, 0.1), c(1,1,1), c(1,2,2), c(1,2,5), c(1,2,1000) )
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=nrow(mult.mat))
norm.predict.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
i <- 1
mult.vec.i <- mult.mat[,i]
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
o <- 2
i <- 2
mult.vec.i <- mult.mat[,i]
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
t(out.est$alpha.hat) %*% out.est$alpha.hat
sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)
t(out.est$alpha.true) %*% out.est$alpha.true
0.03055456/0.1222183
for (i in 1:ncol(mult.mat)) {
mult.vec.i <- mult.mat[,i]
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
norm.predict.mat[j,i] <- sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)   #This is what I predict the norm to be based on theory
}
lm.vec[i] <- summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
}
i
j
i
j
ncol(mult.mat)
p.und <- floor(327273 / 10)
r.und <- 3
n.und <- 100
n.repeat <- 50
mult.mat <- cbind( c(0.1, 0.1, 0.1), c(1,1,1), c(1,2,2), c(1,2,5), c(1,2,1000) )
norm.true.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))     #Simulation results x Simulation Type
norm.est.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))
norm.predict.mat <- matrix(NA, nrow=n.repeat, ncol=ncol(mult.mat))
lm.vec <- rep(NA, length(mult.vec))
Sigma.und <- rep(0.15, p.und)
for (i in 1:ncol(mult.mat)) {
mult.vec.i <- mult.mat[,i]
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
norm.predict.mat[j,i] <- sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)   #This is what I predict the norm to be based on theory
}
lm.vec[i] <- summary(lm(norm.est.mat[,i]~norm.true.mat[,i]))$coefficients[2,1]
}
norm.est.mat
norm.predict.mat
i <- 2
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
i <- 3
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
i <- 4
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
i <- 5
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Multiplier = ", mult.i, ", Slope = ", slope.i))
abline(a=0, b=1, col="red")
ncol(mult.mat)
mult.mat[,i]
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- as.character(mult.mat[,i])
mult.i
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
mult.i
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
par(mfrow=c(3,2), mex=0.85, cex=0.8)
for (i in 1:ncol(mult.mat)) {
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
abline(a=0, b=1, col="red")
}
jpeg(filename = "UnderestimatingOmega_Multipliers_Theorem.jpeg", width=1056, height=629)
par(mfrow=c(3,2), mex=0.85, cex=0.8)
for (i in 1:ncol(mult.mat)) {
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
plot(x.i, y.i, xlab="True Norm(Omega)^2", ylab="Estimated Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
abline(a=0, b=1, col="red")
}
dev.off()
jpeg(filename = "UnderestimatingOmega_Multipliers_Theorem.jpeg", width=1056, height=629)
par(mfrow=c(3,2), mex=0.85, cex=0.8)
for (i in 1:ncol(mult.mat)) {
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
plot(x.i, y.i, xlab="Estimated Norm(Omega)^2", ylab="Predicted Norm(Omega)^2 Based on Theorem", main=paste0("Lambda's = ", mult.i))
abline(a=0, b=1, col="red")
}
dev.off()
jpeg(filename = "UnderestimatingOmega_Multipliers_Theorem.jpeg", width=1056, height=629)
par(mfrow=c(3,2), mex=0.85, cex=0.8)
for (i in 1:ncol(mult.mat)) {
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
plot(x.i, y.i, xlab="Estimated Norm(Omega)^2", ylab="Thm 1 Predicted Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
abline(a=0, b=1, col="red")
}
dev.off()
mult.mat <- cbind( c(0.1, 0.1, 0.1), c(1,1,1), c(1,2,2), c(1,2,5), c(1,2,10000) )
i <- 5
Gamma.und <- sweep(matrix(rnorm(r.und*p.und), nrow=p.und, ncol=r.und) * sqrt(0.15), MARGIN=2, sqrt(mult.vec.i/n.und), '*')
V.und <- svd(t(Gamma.und / Sigma.und) %*% Gamma.und)$v
Gamma.und <- Gamma.und %*% V.und
for (j in 1:n.repeat) {
X.und <- cbind(rep(1,n.und), rbinom(n=n.und, size=1, prob=0.5))
alpha.und <- matrix(max(rnorm(1)*0.05 + 0.2, 0.1), nrow=r.und, ncol=1)
out.est <- CompareEstimate(X.und, alpha.und, Gamma.und, Sigma.und)
norm.true.mat[j,i] <- t(out.est$alpha.true) %*% out.est$alpha.true
norm.est.mat[j,i] <- t(out.est$alpha.hat) %*% out.est$alpha.hat
norm.predict.mat[j,i] <- sum(out.est$alpha.true^2 * (mult.vec.i[order(-mult.vec.i)]/(mult.vec.i[order(-mult.vec.i)]+1))^2)   #This is what I predict the norm to be based on theory
}
i <- 5
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
plot(x.i, y.i, xlab="Estimated Norm(Omega)^2", ylab="Thm 1 Predicted Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
abline(a=0, b=1, col="red")
x.i <- norm.est.mat[,i]
y.i <- norm.predict.mat[,i]
slope.i <- as.character(round(100*lm.vec[i])/100)
mult.i <- paste(as.character(mult.mat[,i]), collapse = ", ")
plot(x.i, y.i, xlab="Estimated Norm(Omega)^2", ylab="Thm 1 Predicted Norm(Omega)^2", main=paste0("Lambda's = ", mult.i))
abline(a=0, b=1, col="red")
