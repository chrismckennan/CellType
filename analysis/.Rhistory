Gamma <- cbind(Gamma[ind.use])
}
}
alpha.0 <- solve( t(Gamma) %*% Gamma + q * inv.V.Omega, t(Gamma) %*% Y + q * inv.V.Omega %*% Omega )       #Penalized least squares as a starting point
diff <- 1 + tol
p.hub <- nrow(Gamma)
for (iter in 1:max.iter) {
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
}
return(list(alpha=alpha.0, n.iter=iter, out=0))
}
psi.huber <- function(x, k) {
ind.small <- as.numeric(abs(x) <= k)
return( ind.small * x/k + (1 - ind.small) * sign.vec(x) )
}
Second.Deriv <- function(x, k) {
ind.small <- as.numeric(abs(x) <= k)
return( ind.small * 1/k )
}
sign.vec <- function(x) {
return( as.numeric( x > 0 ) - as.numeric( x < 0 ) )
}
rho.huber <- function(x, k) {
ind.small <- abs(x) <= k
return( sum(1/2/k * x[ind.small]^2) + sum(abs(x[!ind.small]) - k/2) )
}
fun.value <- function(x, k, diff, inv.V, q) {
return( (rho.huber(x, k) + q/2 * t(diff) %*% inv.V %*% diff)/p )
}
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000], q=1, max.iter=1e4)
alpha.penalized.est
length(Gamma)
k.hub
inv.V.Omega
matrix(inv.V.use, nrow=1, ncol=1)
Omega
inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1)
Y=Y.tilde.hub.use[,3]; Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1]; Gamma=cbind(analyzed.data$Effects.cell[,5]); Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1); inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1); ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000]; q=1; max.iter=1e4
K <- ncol(Gamma)
if (! is.null(ind.use)) {
Y <- Y[ind.use]
Sigma <- Sigma[ind.use]
if (K > 1) {
Gamma <- Gamma[ind.use,]
} else {
Gamma <- cbind(Gamma[ind.use])
}
}
alpha.0 <- solve( t(Gamma) %*% Gamma + q * inv.V.Omega, t(Gamma) %*% Y + q * inv.V.Omega %*% Omega )       #Penalized least squares as a starting point
diff <- 1 + tol
p.hub <- nrow(Gamma)
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
dir.0
sum(P.vec)
sum(P.vec)*k.hub
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
P.vec <- Second.Deriv((Y - Gamma %*% alpha.0)/Sigma, k.hub)
tmp.mat <- Gamma / Sigma^2 * P.vec
H.0 <- t(tmp.mat) %*% Gamma + q * inv.V.Omega
dir.0 <- -solve(H.0, grad.0)
if (K > 1) {
alpha.0 <- alpha.0 + dir.0
} else {
alpha.0 <- alpha.0 + matrix(dir.0, nrow=1, ncol=1)
}
alpha.0
sum(P.vec)
H.0
q * inv.V.Omega
t(tmp.mat) %*% Gamma
dir.0
alpha.0 - Omega
Omega
alpha.0
grad.0
q * inv.V.Omega %*% (alpha.0 - Omega)
apply( Gamma/Sigma * psi.0, 2, sum )
psi.0 <- psi.huber( (Y - Gamma %*% alpha.0)/Sigma, k.hub )     #A p-vector
f.0 <- fun.value((Y - Gamma %*% alpha.0)/Sigma, k.hub, alpha.0 - Omega, inv.V.Omega, q)     #A scalar
if (K > 1) {
grad.0 <- q * inv.V.Omega %*% (alpha.0 - Omega) - apply( Gamma/Sigma * psi.0, 2, sum )
diff <- max(abs(grad.0))
} else {
grad.0 <- as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega)) - sum(Gamma * psi.0 / Sigma)
diff <- abs(grad.0)
}
if (diff < tol) {
return(list(alpha=alpha.0, n.iter=iter, out=1))
}
grad.0
sum(Gamma * psi.0 / Sigma)
as.numeric(q * inv.V.Omega %*% (alpha.0 - Omega))
grad.0
Y=Y.tilde.hub.use[,3]; Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1]; Gamma=cbind(analyzed.data$Effects.cell[,5]); Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1); inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1); ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000]; q=1; max.iter=1e4
K <- ncol(Gamma)
if (! is.null(ind.use)) {
Y <- Y[ind.use]
Sigma <- Sigma[ind.use]
if (K > 1) {
Gamma <- Gamma[ind.use,]
} else {
Gamma <- cbind(Gamma[ind.use])
}
}
Gamma <- Gamma / Sigma
Y <- Y / Sigma + Gamma %*% Omega
alpha.tilde.0 <- solve( t(Gamma) %*% Gamma + q * inv.V.Omega, t(Gamma) %*% Y)       #Penalized least squares as a starting point
diff <- 1 + tol
p.hub <- nrow(Gamma)
alpha.tilde.0 + Omega
alpha.tilde.0
Y=Y.tilde.hub.use[,3]; Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1]; Gamma=cbind(analyzed.data$Effects.cell[,5]); Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1); inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1); ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000]; q=1; max.iter=1e4
K <- ncol(Gamma)
if (! is.null(ind.use)) {
Y <- Y[ind.use]
Sigma <- Sigma[ind.use]
if (K > 1) {
Gamma <- Gamma[ind.use,]
} else {
Gamma <- cbind(Gamma[ind.use])
}
}
Gamma <- Gamma / Sigma
Y <- Y / Sigma - Gamma %*% Omega
alpha.tilde.0 <- solve( t(Gamma) %*% Gamma + q * inv.V.Omega, t(Gamma) %*% Y)       #Penalized least squares as a starting point
diff <- 1 + tol
p.hub <- nrow(Gamma)
alpha.tilde.0 + Omega
alpha.tilde.0
psi.0 <- psi.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
if (K == 1) {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - sum(Gamma * psi.0)
diff <- abs(grad.0)
} else {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - apply(Gamma * psi.0, 2, sum)
diff <- max(abs(grad.0))
}
grad.0
diff
Weights.huber <- function(x, k) {
ind.small <- as.numeric(abs(x) <= k)
return( ind.small * 1/k + (1-ind.small) / abs(x) )
}
weights.0 <- Weights.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
weights.0[1:10]
tmp.mat <- Gamma * weights.0
alpha.tilde.0 <- solve( t(tmp.mat) %*% Gamma + q * inv.V.Omega, t(tmp.mat) %*% Y )
alpha.tilde.0
if (K == 1) {
alpha.tilde.0 <- matrix(alpha.tilde.0, nrow=1, ncol=1)
}
psi.0 <- psi.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
if (K == 1) {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - sum(Gamma * psi.0)
diff <- abs(grad.0)
} else {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - apply(Gamma * psi.0, 2, sum)
diff <- max(abs(grad.0))
}
diff
for (iter in 1:max.iter) {
psi.0 <- psi.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
if (K == 1) {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - sum(Gamma * psi.0)
diff <- abs(grad.0)
} else {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - apply(Gamma * psi.0, 2, sum)
diff <- max(abs(grad.0))
}
if (diff < tol) {
return(list(alpha=alpha.tilde.0 + Omega, n.iter=iter, out=1))
}
weights.0 <- Weights.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
tmp.mat <- Gamma * weights.0
alpha.tilde.0 <- solve( t(tmp.mat) %*% Gamma + q * inv.V.Omega, t(tmp.mat) %*% Y )
if (K == 1) {
alpha.tilde.0 <- matrix(alpha.tilde.0, nrow=1, ncol=1)
}
}
iter
diff
alpha.tilde.0
alpha.tilde.0 + Omega
Pen.Huber <- function(Y, Sigma, Gamma, Omega, inv.V.Omega, k.hub = 1.345, ind.use=NULL, q = 1, max.iter=1e4, tol=1e-8) {
K <- ncol(Gamma)
if (! is.null(ind.use)) {
Y <- Y[ind.use]
Sigma <- Sigma[ind.use]
if (K > 1) {
Gamma <- Gamma[ind.use,]
} else {
Gamma <- cbind(Gamma[ind.use])
}
}
Gamma <- Gamma / Sigma
Y <- Y / Sigma - Gamma %*% Omega
alpha.tilde.0 <- solve( t(Gamma) %*% Gamma + q * inv.V.Omega, t(Gamma) %*% Y)       #Penalized least squares as a starting point
for (iter in 1:max.iter) {
psi.0 <- psi.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
if (K == 1) {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - sum(Gamma * psi.0)
diff <- abs(grad.0)
} else {
grad.0 <- q * inv.V.Omega %*% alpha.tilde.0 - apply(Gamma * psi.0, 2, sum)
diff <- max(abs(grad.0))
}
if (diff < tol) {
return(list(alpha=alpha.tilde.0 + Omega, n.iter=iter, out=1))
}
weights.0 <- Weights.huber(Y - Gamma %*% alpha.tilde.0, k.hub)
tmp.mat <- Gamma * weights.0
alpha.tilde.0 <- solve( t(tmp.mat) %*% Gamma + q * inv.V.Omega, t(tmp.mat) %*% Y )
if (K == 1) {
alpha.tilde.0 <- matrix(alpha.tilde.0, nrow=1, ncol=1)
}
}
return(list(alpha=alpha.0, n.iter=iter, out=0))
}
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000], q=1, max.iter=1e4)
alpha.penalized.est
alpha.penalized.oracle <- Pen.Huber(Y.tilde.hub.use[,3], sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], cbind(analyzed.data$Effects.cell[,5]), matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(-abs(L.sim[,3]))[1:1000], q=1)
alpha.penalized.oracle
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:100], q=1, max.iter=1e4)
alpha.penalized.oracle
alpha.penalized.est
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:100], q=100, max.iter=1e4)
alpha.penalized.est
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma), Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000], q=1, max.iter=1e4)
alpha.penalized.est
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000], q=1, max.iter=1e4)
alpha.penalized.est
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma), Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:100000], q=1, max.iter=1e4)
alpha.penalized.est
R.tmp[d.sim+1,d.sim+1]
alpha.penalized.oracle <- Pen.Huber(Y.tilde.hub.use[,3], sqrt(analyzed.data$cate.nocell$Sigma), cbind(analyzed.data$Effects.cell[,5]), matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(-abs(L.sim[,3]))[1:1000], q=1)
alpha.penalized.oracle
alpha.penalized.oracle <- Pen.Huber(Y.tilde.hub.use[,3], sqrt(analyzed.data$cate.nocell$Sigma)/R.tmp[d.sim+1,d.sim+1], cbind(analyzed.data$Effects.cell[,5]), matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(-abs(L.sim[,3]))[1:1000], q=0)
alpha.penalized.oracle
alpha.penalized.oracle <- Pen.Huber(Y.tilde.hub.use[,3], sqrt(analyzed.data$cate.nocell$Sigma), cbind(analyzed.data$Effects.cell[,5]), matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(-abs(L.sim[,3]))[1:1000], q=0)
alpha.penalized.oracle
alpha.penalized.oracle <- Pen.Huber(Y.tilde.hub.use[,3], sqrt(analyzed.data$cate.nocell$Sigma), cbind(analyzed.data$Effects.cell[,5]), matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(-abs(L.sim[,3]))[1:100], q=0)
alpha.penalized.oracle
alpha.penalized.oracle <- Pen.Huber(Y.tilde.hub.use[,3], sqrt(analyzed.data$cate.nocell$Sigma), cbind(analyzed.data$Effects.cell[,5]), matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(-abs(L.sim[,3]))[1:50], q=0)
alpha.penalized.oracle
sqrt(1/inv.V.total)
sqrt(1/inv.V.total[9,9])
Omega.data
Omega.sim
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma), Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000], q=0)
alpha.penalized.est
alpha.penalized.est <- Pen.Huber(Y=Y.tilde.hub.use[,3], Sigma=sqrt(analyzed.data$cate.nocell$Sigma), Gamma=cbind(analyzed.data$Effects.cell[,5]), Omega=matrix(Omega.data[3,d.sim+1], nrow=1, ncol=1), inv.V.Omega=matrix(inv.V.use, nrow=1, ncol=1), ind.use=order(analyzed.data$q.neutro$qvalue)[1:1000], q=1)
alpha.penalized.est
sigma.L.sim
Omega.sim
Omega.data
var.cell
alpha.cell.sim
Var.cell
R.ce
R.cell
sigma.neutro <- sigma.L.sim[3]
mean.cell <- Omega.sim %*% t(X.sim)    #A K x n matrix
Var.cell <- 1/(alpha.cell.sim + 1) * ( diag(mean.cell[,1], nrow=nrow(Omega.sim), ncol=nrow(Omega.sim)) - cbind(mean.cell[,1]) %*% rbind(mean.cell[,1]) )
R.cell <- t(chol(Var.cell))     #RR' = Var.cell => LC = LOmegaX + LRW, W ~ MN(0, I_K, I_n)
R.neutro <- sqrt(sum(R.cell[3,]))
R.neutro <- sqrt(sum(R.cell[3,]^2))
R.neutro
R.neutro <- sqrt(sum(R.cell[3,]^2))
omega.neutro <- Omega.sim[3,3]
omega.neutro
sigma.neutro
sigma.neutro * R.neutro
omega.neutro/R.neutro
sigma.neutro * R.neutro * p
p
sqrt(0.15)
sqrt(0.15)/sqrt(100)
sqrt(0.15/10)/sqrt(100)
exp.L.size <- sigma.neutro * R.neutro
exp.noise.size <- sqrt(0.15) / sqrt(n.sim)
exp.L.sie
exp.L.size
exp.noise.size
corr.size <- Omega.sim[3,3] / R.neutro
corr.size
n.sim <- 100   #Number of individuals
r.sim <- 5     #Number of additional confounders
K.sim <- 3     #Number of cell types
d.sim <- 1     #Number of interesting covariates (either 0 or 1)
pi0.B.sim <- rep(0.95, d.sim)    #Sparsity in B
pi0.L.sim <- c(1, 1, 0.7)    #Sparsity in L
LB.ind <- 1     #Are L and B independent? If no, the confounder Eos will have nonzero effects on the same sites as B[nonzero,1]
mu.sigma.sim <- 0.15
v.sigma.sim <- 0.03^2
beta.sigma <- mu.sigma.sim/v.sigma.sim
alpha.sigma <- beta.sigma * mu.sigma.sim     #Sigma ~ Gamma(alpha.sigma, beta.sigma)
sigma.B.sim <- rep(mu.sigma.sim, d.sim)
Omega.sim <- Omega.QL
Omega.sim[1,3] <- 0.04
Omega.sim[2,3] <- 0.02
Omega.sim <- Omega.sim[,-c(2,4)]
alpha.cell.sim <- (1/var.cell - 1)
sigma.L.sim <- c(1, 1, 1) / Omega.QL[1:3,1] * sqrt(0.15)
sigma.r.sim <- c(0.15, 0.15, 0.15, 0.15, 0.15)
##Simulate Data##
SimData <- Sim.Data(n.sim, r.sim, p, pi0.B.sim, pi0.L.sim, LB.ind, sigma.B.sim, sigma.L.sim, sigma.r.sim, Omega.sim, alpha.cell.sim, alpha.sigma, beta.sigma)
M.sim <- SimData$M.sim
X.sim <- SimData$X.sim
L.sim <- SimData$L.sim
B.sim <- SimData$B.sim
Sigma.sim <- SimData$Sigma.sim
Gamma.sim <- SimData$Gamma.sim
C.sim <- SimData$C.sim    #n x K.all matrix
data.sim <- data.frame(cbind(X.sim, C.sim))
colnames(data.sim) <- c("Intercept", "Cov1", "Tcells", "Eos", "Neutro")
##Analyze data with and without cell type data##
#No cell type info#
#conf.nocell.sim <- est.confounder.num(~Cov1 + Cov2, X.data=data.sim, Y=t(M.sim), method="ed", bcv.plot = T, rmax=10); r.nocell.sim <- conf.nocell.sim$r
analyzed.data <- AnalyzeData2(M.sim, data.sim, r.sim, r.sim+1, B.sim, L.sim)
dim(X.sim)
X.sim[,1]
X.sim[,2]
seed()
set.seed()
Omega.sim
dim(C.sim)
solve(t(X.sim) %*% X.sim) %*% t(X.sim) %*% C.sim
